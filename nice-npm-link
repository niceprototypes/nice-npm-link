#!/usr/bin/env node
/**
 * nice-npm-link (enhanced)
 * - Links a local package (components library) into the current project
 * - Prevents duplicate React (and friends) by:
 *     1) enforcing peerDependencies in the linked package
 *     2) removing conflicting deps from the LINKED PACKAGE's node_modules
 * - Detects package manager (npm | yarn | pnpm) with override
 * - Safer cwd handling, optional dry-run, clearer logs
 *
 * Usage:
 *   nnl <path> [--dry-run] [--clean-only]
 *       [--exclude a,b,c] [--add-exclude x,y]
 *       [--manager npm|yarn|pnpm] [--skip-peer-check]
 *
 * Examples:
 *   nnl ../my-lib
 *   nnl --clean-only --add-exclude @emotion/react,@emotion/styled ../my-lib
 *   nnl --manager pnpm ../my-lib
 */

const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

// -------- Config --------
const DEFAULT_CONFLICTING_PACKAGES = [
  'react',
  'react-dom',
  'scheduler',
  'react-is',
  'styled-components',
  '@emotion/react',
  '@emotion/styled',
  '@types/react',
  '@types/react-dom'
];

const PEER_ENFORCE = ['react', 'react-dom'];

// -------- Utils --------
const cyan = s => `\x1b[36m${s}\x1b[0m`;
const gray = s => `\x1b[90m${s}\x1b[0m`;
const green = s => `\x1b[32m${s}\x1b[0m`;
const red = s => `\x1b[31m${s}\x1b[0m`;
const yellow = s => `\x1b[33m${s}\x1b[0m`;

function log(msg) { console.log(`üì¶ ${msg}`); }
function info(msg) { console.log(gray(`‚ÑπÔ∏é ${msg}`)); }
function success(msg) { console.log(green(`‚úÖ ${msg}`)); }
function warn(msg) { console.log(yellow(`‚ö†Ô∏è  ${msg}`)); }
function fail(msg) { console.error(red(`‚ùå ${msg}`)); }

function showUsage() {
  console.log(`
${cyan('nice-npm-link (enhanced)')}

Usage:
  nnl <package-path> [options]

Options:
  --clean-only               Only clean conflicts in the linked package; do not link
  --exclude <a,b,c>          Comma-separated list of packages to remove (overrides defaults)
  --add-exclude <a,b,c>      Comma-separated list of additional packages to remove
  --dry-run                  Show what would happen without making changes
  --manager <npm|yarn|pnpm>  Force a package manager (auto-detected by default)
  --skip-peer-check          Do not auto-move react/react-dom to peerDependencies
  --help, -h                 Show help

Notes:
  ‚Ä¢ Conflicts are removed from the ${cyan('LINKED PACKAGE')} node_modules, not your app.
  ‚Ä¢ Ensure your component library lists React as peerDependency.
  ‚Ä¢ For CRA, you may need: export NODE_OPTIONS=--preserve-symlinks
  ‚Ä¢ Workspaces often remove the need for manual linking; consider "workspace:" or local file deps.
`);
}

// -------- Arg parsing --------
function parseList(s) {
  return s.split(',').map(x => x.trim()).filter(Boolean);
}

function getArg(args, name) {
  const i = args.indexOf(name);
  return i !== -1 ? args[i + 1] : null;
}

function detectPM(cwd = process.cwd()) {
  if (fs.existsSync(path.join(cwd, 'pnpm-lock.yaml'))) return 'pnpm';
  if (fs.existsSync(path.join(cwd, 'yarn.lock'))) return 'yarn';
  return 'npm';
}

function run(pm, argv, opts = {}) {
  const cmd = pm;
  const result = spawnSync(cmd, argv, { stdio: 'inherit', shell: process.platform === 'win32', ...opts });
  if (result.error) throw result.error;
  if (result.status !== 0) throw new Error(`${cmd} ${argv.join(' ')} exited with code ${result.status}`);
}

function readJSON(file) {
  return JSON.parse(fs.readFileSync(file, 'utf8'));
}

function writeJSON(file, obj) {
  fs.writeFileSync(file, JSON.stringify(obj, null, 2));
}

// -------- Core helpers --------
function removeConflictsInDir(dir, packages, { dryRun } = {}) {
  const nm = path.join(dir, 'node_modules');
  if (!fs.existsSync(nm)) {
    info(`No node_modules in ${dir}, skipping clean`);
    return;
  }
  if (!packages.length) return;

  log(`Cleaning conflicts in ${gray(dir)}: ${packages.join(', ')}`);
  for (const pkg of packages) {
    const p = path.join(nm, pkg);
    if (fs.existsSync(p)) {
      if (dryRun) {
        info(`[dry-run] would remove ${p}`);
      } else {
        try {
          fs.rmSync(p, { recursive: true, force: true });
          success(`Removed ${gray(path.relative(process.cwd(), p))}`);
        } catch (e) {
          fail(`Failed to remove ${pkg} in ${dir}: ${e.message}`);
        }
      }
    }
  }
}

function ensurePeerDeps(packageDir, names, { dryRun } = {}) {
  const pjPath = path.join(packageDir, 'package.json');
  const pj = readJSON(pjPath);
  let changed = false;

  pj.peerDependencies = pj.peerDependencies || {};
  pj.devDependencies = pj.devDependencies || {};
  pj.dependencies = pj.dependencies || {};

  for (const name of names) {
    if (pj.dependencies[name]) {
      const current = pj.dependencies[name];
      const range = typeof current === 'string' ? current : '*';
      if (!pj.peerDependencies[name]) pj.peerDependencies[name] = range.startsWith('^') ? range : `^${range.replace(/^[^\d]*/, '')}`;
      delete pj.dependencies[name];
      changed = true;
      log(`Moved ${cyan(name)} -> peerDependencies in linked package`);
    }
  }

  if (changed) {
    if (dryRun) {
      info(`[dry-run] would write updated peerDependencies to ${pjPath}`);
    } else {
      writeJSON(pjPath, pj);
      success('Updated package.json (peerDependencies)');
    }
  }
}

function readPkgName(dir) {
  const pj = readJSON(path.join(dir, 'package.json'));
  if (!pj.name) throw new Error('linked package has no "name" in package.json');
  return pj.name;
}

function isWorkspaceRoot(cwd = process.cwd()) {
  try {
    const pj = readJSON(path.join(cwd, 'package.json'));
    return Boolean(pj.workspaces);
  } catch { return false; }
}

function linkWithPM(pm, pkgDir, pkgName, { dryRun } = {}) {
  if (dryRun) {
    info(`[dry-run] would run ${pm} link (in ${pkgDir}) and ${pm} link ${pkgName} (in project)`);
    return;
  }

  // create global link
  run(pm, ['--version'], { stdio: 'pipe' }); // quick validation
  const original = process.cwd();
  try {
    process.chdir(pkgDir);
    if (pm === 'npm') run('npm', ['link']);
    else if (pm === 'yarn') run('yarn', ['link']);
    else if (pm === 'pnpm') run('pnpm', ['link', '--global']);
    success(`Created global link for ${cyan(pkgName)}`);
  } finally {
    process.chdir(original);
  }

  // link into project
  if (pm === 'npm') run('npm', ['link', pkgName]);
  else if (pm === 'yarn') run('yarn', ['link', pkgName]);
  else if (pm === 'pnpm') {
    // pnpm supports linking by name if globally linked; otherwise fallback to dir
    try {
      run('pnpm', ['link', pkgName]);
    } catch {
      warn('pnpm name link failed; attempting direct path link');
      run('pnpm', ['link', pkgDir]);
    }
  }
  success(`Linked ${cyan(pkgName)} to project`);
}

// -------- Main --------
function main() {
  const args = process.argv.slice(2);
  if (args.includes('--help') || args.includes('-h') || args.length === 0) {
    showUsage();
    process.exit(0);
  }

  // options
  let packagesToRemove = [...DEFAULT_CONFLICTING_PACKAGES];
  const exclude = getArg(args, '--exclude');
  if (exclude) {
    packagesToRemove = parseList(exclude);
    log(`Using custom exclude list: ${packagesToRemove.join(', ')}`);
  }
  const addExclude = getArg(args, '--add-exclude');
  if (addExclude) {
    packagesToRemove = [...new Set([...packagesToRemove, ...parseList(addExclude)])];
    log(`Adding to exclude list: ${addExclude}`);
  }

  const dryRun = args.includes('--dry-run');
  const cleanOnly = args.includes('--clean-only');
  const skipPeerCheck = args.includes('--skip-peer-check');
  const forcedPM = getArg(args, '--manager');
  const pm = forcedPM || detectPM(process.cwd());

  if (forcedPM) info(`Using forced package manager: ${cyan(pm)}`);
  else info(`Detected package manager: ${cyan(pm)}`);

  // package path (first non-flag arg that isn't value of a flag)
  const skipValuesFor = new Set(['--exclude', '--add-exclude', '--manager']);
  const pkgPathArg = args.find((arg, i) => {
    if (arg.startsWith('--')) return false;
    const prev = args[i - 1];
    if (prev && skipValuesFor.has(prev)) return false;
    return true;
  });

  if (!pkgPathArg && !cleanOnly) {
    fail('Please provide a path to the package you want to link');
    showUsage();
    process.exit(1);
  }

  if (isWorkspaceRoot() && !forcedPM && !cleanOnly) {
    warn('Workspaces detected. Consider using "workspace:" or local file deps instead of linking.');
  }

  const projectDir = process.cwd();

  if (cleanOnly) {
    if (!pkgPathArg) {
      fail('Provide the linked package path to clean its node_modules');
      process.exit(1);
    }
    const resolved = path.resolve(pkgPathArg);
    if (!fs.existsSync(resolved)) { fail(`Path does not exist: ${resolved}`); process.exit(1); }
    if (!fs.existsSync(path.join(resolved, 'package.json'))) { fail(`No package.json in ${resolved}`); process.exit(1); }

    if (!skipPeerCheck) ensurePeerDeps(resolved, PEER_ENFORCE, { dryRun });
    removeConflictsInDir(resolved, packagesToRemove, { dryRun });
    success('Cleanup completed');
    process.exit(0);
  }

  // Full link flow
  const resolved = path.resolve(pkgPathArg);
  if (!fs.existsSync(resolved)) { fail(`Path does not exist: ${resolved}`); process.exit(1); }
  if (!fs.existsSync(path.join(resolved, 'package.json'))) { fail(`No package.json in ${resolved}`); process.exit(1); }

  // 1) enforce peer deps in linked package
  if (!skipPeerCheck) ensurePeerDeps(resolved, PEER_ENFORCE, { dryRun });

  // 2) remove conflicting packages in the LINKED package node_modules
  removeConflictsInDir(resolved, packagesToRemove, { dryRun });

  // 3) link using detected pm
  const pkgName = readPkgName(resolved);
  linkWithPM(pm, resolved, pkgName, { dryRun });

  // 4) Advice: CRA symlinks
  try {
    const pj = readJSON(path.join(projectDir, 'package.json'));
    const deps = { ...pj.dependencies, ...pj.devDependencies };
    if (deps && deps['react-scripts']) {
      info('CRA detected. If module resolution errors occur, try:');
      info('  export NODE_OPTIONS=--preserve-symlinks  (bash/zsh)');
      info('  setx NODE_OPTIONS "--preserve-symlinks"  (Windows)');
    }
  } catch {}

  // 5) final clean inside linked package (sometimes link reinstalls)
  removeConflictsInDir(resolved, packagesToRemove, { dryRun });

  success(`Successfully linked ${cyan(pkgName)}!`);
  log('Next steps: edit your linked package and restart dev server if required.');
  log(`To unlink: ${pm} unlink ${pkgName}`);
}

if (require.main === module) {
  try { main(); }
  catch (e) { fail(e.message || String(e)); process.exit(1); }
}

module.exports = {
  detectPM,
  ensurePeerDeps,
  removeConflictsInDir
};
