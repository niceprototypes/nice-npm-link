#!/usr/bin/env node
/**
 * nice-npm-link (enhanced)
 * - Links a local package (components library) into the current project
 * - Prevents duplicate React (and friends) by:
 *     1) enforcing peerDependencies in the linked package
 *     2) removing conflicting deps from the LINKED PACKAGE's node_modules
 * - Detects package manager (npm | yarn | pnpm) with override
 * - Safer cwd handling, optional dry-run, clearer logs
 *
 * Usage:
 *   nnl <path> [--dry-run] [--clean-only]
 *       [--exclude a,b,c] [--add-exclude x,y]
 *       [--manager npm|yarn|pnpm] [--skip-peer-check]
 *
 * Examples:
 *   nnl ../my-lib
 *   nnl --clean-only --add-exclude @emotion/react,@emotion/styled ../my-lib
 *   nnl --manager pnpm ../my-lib
 */

const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

// -------- Config --------
/**
 * Default list of packages that commonly cause conflicts when linking React component libraries.
 * These packages are removed from the linked package's node_modules to prevent duplicate instances.
 *
 * @constant {string[]}
 * @description Includes:
 *   - React core packages (react, react-dom, scheduler, react-is)
 *   - Styling libraries that depend on React context (styled-components, @emotion/*)
 *   - TypeScript definitions that can conflict (@types/react, @types/react-dom)
 */
const DEFAULT_CONFLICTING_PACKAGES = [
  'react',
  'react-dom',
  'scheduler',
  'react-is',
  'styled-components',
  '@emotion/react',
  '@emotion/styled',
  '@types/react',
  '@types/react-dom'
];

/**
 * Packages that should be automatically moved to peerDependencies in the linked package.
 * This ensures the linked package uses the host project's version of these packages.
 *
 * @constant {string[]}
 */
const PEER_ENFORCE = ['react', 'react-dom'];

// -------- Utils --------
/**
 * Terminal color formatters using ANSI escape codes
 */
const cyan = s => `\x1b[36m${s}\x1b[0m`;
const gray = s => `\x1b[90m${s}\x1b[0m`;
const green = s => `\x1b[32m${s}\x1b[0m`;
const red = s => `\x1b[31m${s}\x1b[0m`;
const yellow = s => `\x1b[33m${s}\x1b[0m`;

/**
 * Logging utilities with consistent formatting and icons
 */
function log(msg) { console.log(`üì¶ ${msg}`); }
function info(msg) { console.log(gray(`‚ÑπÔ∏é ${msg}`)); }
function success(msg) { console.log(green(`‚úÖ ${msg}`)); }
function warn(msg) { console.log(yellow(`‚ö†Ô∏è  ${msg}`)); }
function fail(msg) { console.error(red(`‚ùå ${msg}`)); }

/**
 * Displays the usage help text with all available options
 */
function showUsage() {
  console.log(`
${cyan('nice-npm-link (enhanced)')}

Usage:
  nnl <package-path> [options]

Options:
  --clean-only               Only clean conflicts in the linked package; do not link
  --unlink                   Restore npm packages to their original versions
  --exclude <a,b,c>          Comma-separated list of packages to remove (overrides defaults)
  --add-exclude <a,b,c>      Comma-separated list of additional packages to remove
  --dry-run                  Show what would happen without making changes
  --manager <npm|yarn|pnpm>  Force a package manager (auto-detected by default)
  --skip-peer-check          Do not auto-move react/react-dom to peerDependencies
  --help, -h                 Show help

Notes:
  ‚Ä¢ Conflicts are removed from the ${cyan('LINKED PACKAGE')} node_modules, not your app.
  ‚Ä¢ Ensure your component library lists React as peerDependency.
  ‚Ä¢ For CRA, you may need: export NODE_OPTIONS=--preserve-symlinks
  ‚Ä¢ Workspaces often remove the need for manual linking; consider "workspace:" or local file deps.
`);
}

// -------- Arg parsing --------
/**
 * Parses a comma-separated string into an array of trimmed, non-empty values
 *
 * @param {string} s - Comma-separated string (e.g., "react,react-dom,styled-components")
 * @returns {string[]} Array of trimmed package names
 * @example
 *   parseList("react, react-dom, ") // => ["react", "react-dom"]
 */
function parseList(s) {
  return s.split(',').map(x => x.trim()).filter(Boolean);
}

/**
 * Gets the value of a command-line argument by name
 *
 * @param {string[]} args - Command-line arguments array
 * @param {string} name - Flag name to search for (e.g., "--exclude")
 * @returns {string|null} Value following the flag, or null if not found
 * @example
 *   getArg(["--exclude", "react"], "--exclude") // => "react"
 */
function getArg(args, name) {
  const i = args.indexOf(name);
  return i !== -1 ? args[i + 1] : null;
}

/**
 * Auto-detects the package manager used in the project
 *
 * @param {string} [cwd=process.cwd()] - Directory to check for lockfiles
 * @returns {'pnpm'|'yarn'|'npm'} Detected package manager (defaults to 'npm')
 * @description Checks for lockfiles in this order: pnpm-lock.yaml, yarn.lock, then defaults to npm
 */
function detectPM(cwd = process.cwd()) {
  if (fs.existsSync(path.join(cwd, 'pnpm-lock.yaml'))) return 'pnpm';
  if (fs.existsSync(path.join(cwd, 'yarn.lock'))) return 'yarn';
  return 'npm';
}

/**
 * Executes a package manager command synchronously
 *
 * @param {string} pm - Package manager command ('npm', 'yarn', or 'pnpm')
 * @param {string[]} argv - Command arguments
 * @param {object} [opts={}] - Additional spawn options
 * @throws {Error} If the command fails or returns a non-zero exit code
 */
function run(pm, argv, opts = {}) {
  const cmd = pm;
  const result = spawnSync(cmd, argv, { stdio: 'inherit', shell: process.platform === 'win32', ...opts });
  if (result.error) throw result.error;
  if (result.status !== 0) throw new Error(`${cmd} ${argv.join(' ')} exited with code ${result.status}`);
}

/**
 * Reads and parses a JSON file synchronously
 *
 * @param {string} file - Path to JSON file
 * @returns {object} Parsed JSON object
 * @throws {Error} If file cannot be read or parsed
 */
function readJSON(file) {
  return JSON.parse(fs.readFileSync(file, 'utf8'));
}

/**
 * Writes an object to a JSON file with 2-space indentation
 *
 * @param {string} file - Path to output JSON file
 * @param {object} obj - Object to serialize and write
 */
function writeJSON(file, obj) {
  fs.writeFileSync(file, JSON.stringify(obj, null, 2));
}

// -------- Core helpers --------
/**
 * Removes conflicting packages from a directory's node_modules
 *
 * @param {string} dir - Directory containing node_modules to clean
 * @param {string[]} packages - Array of package names to remove
 * @param {object} [options] - Options object
 * @param {boolean} [options.dryRun=false] - If true, only logs what would be removed without actually removing
 * @description This function removes packages from the LINKED package's node_modules to prevent
 *              duplicate instances of React, styling libraries, etc. that can cause runtime errors.
 */
function removeConflictsInDir(dir, packages, { dryRun } = {}) {
  const nm = path.join(dir, 'node_modules');
  if (!fs.existsSync(nm)) {
    info(`No node_modules in ${dir}, skipping clean`);
    return;
  }
  if (!packages.length) return;

  log(`Cleaning conflicts in ${gray(dir)}: ${packages.join(', ')}`);
  for (const pkg of packages) {
    const p = path.join(nm, pkg);
    if (fs.existsSync(p)) {
      if (dryRun) {
        info(`[dry-run] would remove ${p}`);
      } else {
        try {
          fs.rmSync(p, { recursive: true, force: true });
          success(`Removed ${gray(path.relative(process.cwd(), p))}`);
        } catch (e) {
          fail(`Failed to remove ${pkg} in ${dir}: ${e.message}`);
        }
      }
    }
  }
}

/**
 * Ensures specified packages are listed as peerDependencies (not dependencies) in a package
 *
 * @param {string} packageDir - Path to the package directory
 * @param {string[]} names - Package names to move to peerDependencies (e.g., ['react', 'react-dom'])
 * @param {object} [options] - Options object
 * @param {boolean} [options.dryRun=false] - If true, only logs changes without modifying package.json
 * @description Moves packages from dependencies to peerDependencies and adds a prepare script if needed.
 *              This ensures the linked library uses the host project's version of these packages.
 */
function ensurePeerDeps(packageDir, names, { dryRun } = {}) {
  const pjPath = path.join(packageDir, 'package.json');
  const pj = readJSON(pjPath);
  let changed = false;

  pj.peerDependencies = pj.peerDependencies || {};
  pj.devDependencies = pj.devDependencies || {};
  pj.dependencies = pj.dependencies || {};
  pj.scripts = pj.scripts || {};

  for (const name of names) {
    if (pj.dependencies[name]) {
      const current = pj.dependencies[name];
      const range = typeof current === 'string' ? current : '*';
      // Convert to caret range if not already, ensuring compatibility
      if (!pj.peerDependencies[name]) pj.peerDependencies[name] = range.startsWith('^') ? range : `^${range.replace(/^[^\d]*/, '')}`;
      delete pj.dependencies[name];
      changed = true;
      log(`Moved ${cyan(name)} -> peerDependencies in linked package`);
    }
  }

  // Ensure prepare script exists for auto-build on install
  if (!pj.scripts.prepare && pj.scripts.build) {
    pj.scripts.prepare = 'npm run build';
    changed = true;
    log(`Added prepare script for auto-build on install`);
  }

  if (changed) {
    if (dryRun) {
      info(`[dry-run] would write updated package.json to ${pjPath}`);
    } else {
      writeJSON(pjPath, pj);
      success('Updated package.json (peerDependencies & scripts)');
    }
  }
}

/**
 * Reads the package name from a directory's package.json
 *
 * @param {string} dir - Directory containing package.json
 * @returns {string} Package name from package.json
 * @throws {Error} If package.json has no "name" field
 */
function readPkgName(dir) {
  const pj = readJSON(path.join(dir, 'package.json'));
  if (!pj.name) throw new Error('linked package has no "name" in package.json');
  return pj.name;
}

/**
 * Checks if the current directory is a workspace root (monorepo)
 *
 * @param {string} [cwd=process.cwd()] - Directory to check
 * @returns {boolean} True if the directory has a "workspaces" field in package.json
 * @description Used to warn users that workspaces may not need manual linking
 */
function isWorkspaceRoot(cwd = process.cwd()) {
  try {
    const pj = readJSON(path.join(cwd, 'package.json'));
    return Boolean(pj.workspaces);
  } catch { return false; }
}

/**
 * Stores the original package version before linking
 *
 * @param {string} projectDir - Project directory path
 * @param {string} pkgName - Package name being linked
 * @param {string} version - Original version from package.json
 * @description Saves a backup file to restore original versions during unlink
 */
function storeOriginalVersion(projectDir, pkgName, version) {
  const backupDir = path.join(projectDir, '.nice-npm-link');
  if (!fs.existsSync(backupDir)) {
    fs.mkdirSync(backupDir, { recursive: true });
  }

  const backupFile = path.join(backupDir, 'linked-packages.json');
  let backup = {};

  if (fs.existsSync(backupFile)) {
    backup = readJSON(backupFile);
  }

  backup[pkgName] = version;
  writeJSON(backupFile, backup);
  info(`Stored original version: ${cyan(pkgName)}@${version}`);
}

/**
 * Links a local package to the current project using the file: protocol
 *
 * @param {string} pm - Package manager to use ('npm', 'yarn', or 'pnpm')
 * @param {string} pkgDir - Absolute path to the package directory to link
 * @param {string} pkgName - Name of the package being linked
 * @param {object} [options] - Options object
 * @param {boolean} [options.dryRun=false] - If true, only logs what would happen without making changes
 * @description Uses the file: protocol in package.json instead of npm link, which is more reliable
 *              and works better with modern package managers and bundlers.
 * @throws {Error} If package.json is not found in the current directory
 */
function linkWithPM(pm, pkgDir, pkgName, { dryRun } = {}) {
  if (dryRun) {
    info(`[dry-run] would use file: protocol to link ${pkgName}`);
    return;
  }

  // Use file: protocol instead of npm link (more reliable)
  const projectDir = process.cwd();
  const packageJsonPath = path.join(projectDir, 'package.json');

  if (!fs.existsSync(packageJsonPath)) {
    throw new Error('package.json not found in current directory');
  }

  const packageJson = readJSON(packageJsonPath);
  const relativePath = path.relative(projectDir, pkgDir);

  // Store original version if it exists
  const originalVersion = packageJson.dependencies?.[pkgName] || packageJson.devDependencies?.[pkgName];
  if (originalVersion && !originalVersion.startsWith('file:')) {
    storeOriginalVersion(projectDir, pkgName, originalVersion);
  }

  // Update package.json with file: protocol
  packageJson.dependencies = packageJson.dependencies || {};
  packageJson.dependencies[pkgName] = `file:${relativePath}`;

  writeJSON(packageJsonPath, packageJson);
  success(`Updated package.json with file: protocol for ${cyan(pkgName)}`);

  // Install the file dependency
  run(pm, ['install']);
  success(`Installed ${cyan(pkgName)} via file: protocol`);
}

/**
 * Unlinks packages and restores their original npm versions
 *
 * @param {string} pm - Package manager to use ('npm', 'yarn', or 'pnpm')
 * @param {object} [options] - Options object
 * @param {boolean} [options.dryRun=false] - If true, only logs what would happen without making changes
 * @description Restores packages to their original npm versions from the backup file
 */
function unlinkPackages(pm, { dryRun } = {}) {
  const projectDir = process.cwd();
  const packageJsonPath = path.join(projectDir, 'package.json');
  const backupFile = path.join(projectDir, '.nice-npm-link', 'linked-packages.json');

  if (!fs.existsSync(backupFile)) {
    fail('No linked packages found. Nothing to unlink.');
    process.exit(1);
  }

  const backup = readJSON(backupFile);
  const packageJson = readJSON(packageJsonPath);

  let unlinkedCount = 0;

  for (const [pkgName, originalVersion] of Object.entries(backup)) {
    const currentVersion = packageJson.dependencies?.[pkgName] || packageJson.devDependencies?.[pkgName];

    if (currentVersion && currentVersion.startsWith('file:')) {
      if (dryRun) {
        info(`[dry-run] would restore ${pkgName} to ${originalVersion}`);
      } else {
        // Restore to original version
        if (packageJson.dependencies?.[pkgName]) {
          packageJson.dependencies[pkgName] = originalVersion;
        } else if (packageJson.devDependencies?.[pkgName]) {
          packageJson.devDependencies[pkgName] = originalVersion;
        }
        success(`Restored ${cyan(pkgName)} to ${originalVersion}`);
        unlinkedCount++;
      }
    }
  }

  if (!dryRun && unlinkedCount > 0) {
    writeJSON(packageJsonPath, packageJson);
    success('Updated package.json');

    log('Installing packages from npm...');
    run(pm, ['install']);
    success('Installed packages from npm');

    // Clean up backup file
    fs.rmSync(backupFile);
    const backupDir = path.join(projectDir, '.nice-npm-link');
    if (fs.existsSync(backupDir) && fs.readdirSync(backupDir).length === 0) {
      fs.rmdirSync(backupDir);
    }

    success(`Unlinked ${unlinkedCount} package(s)`);
  } else if (!dryRun) {
    info('No linked packages to unlink');
  }
}

// -------- Main --------
/**
 * Main entry point for the nice-npm-link CLI tool
 *
 * @description Orchestrates the entire linking workflow:
 *              1. Parses command-line arguments
 *              2. Detects or forces package manager (npm/yarn/pnpm)
 *              3. Moves React packages to peerDependencies in linked package
 *              4. Removes conflicting packages from linked package's node_modules
 *              5. Links the package using file: protocol
 *              6. Provides next steps and helpful advice
 */
function main() {
  const args = process.argv.slice(2);
  if (args.includes('--help') || args.includes('-h') || args.length === 0) {
    showUsage();
    process.exit(0);
  }

  // Parse options: Build the list of packages to remove from linked package
  let packagesToRemove = [...DEFAULT_CONFLICTING_PACKAGES];
  const exclude = getArg(args, '--exclude');
  if (exclude) {
    // --exclude completely overrides the default list
    packagesToRemove = parseList(exclude);
    log(`Using custom exclude list: ${packagesToRemove.join(', ')}`);
  }
  const addExclude = getArg(args, '--add-exclude');
  if (addExclude) {
    // --add-exclude adds to the list (either default or custom from --exclude)
    // Use Set to deduplicate in case user specifies same package twice
    packagesToRemove = [...new Set([...packagesToRemove, ...parseList(addExclude)])];
    log(`Adding to exclude list: ${addExclude}`);
  }

  const dryRun = args.includes('--dry-run');
  const cleanOnly = args.includes('--clean-only');
  const unlink = args.includes('--unlink');
  const skipPeerCheck = args.includes('--skip-peer-check');
  const forcedPM = getArg(args, '--manager');
  const pm = forcedPM || detectPM(process.cwd());

  if (forcedPM) info(`Using forced package manager: ${cyan(pm)}`);
  else info(`Detected package manager: ${cyan(pm)}`);

  // Handle unlink mode
  if (unlink) {
    unlinkPackages(pm, { dryRun });
    process.exit(0);
  }

  // Extract package path: Find the first positional argument that isn't a flag or flag value
  // This allows flexible ordering like: nnl ../lib --exclude react,react-dom
  const skipValuesFor = new Set(['--exclude', '--add-exclude', '--manager']);
  const pkgPathArg = args.find((arg, i) => {
    if (arg.startsWith('--')) return false;
    const prev = args[i - 1];
    if (prev && skipValuesFor.has(prev)) return false;
    return true;
  });

  if (!pkgPathArg && !cleanOnly) {
    fail('Please provide a path to the package you want to link');
    showUsage();
    process.exit(1);
  }

  if (isWorkspaceRoot() && !forcedPM && !cleanOnly) {
    warn('Workspaces detected. Consider using "workspace:" or local file deps instead of linking.');
  }

  const projectDir = process.cwd();

  if (cleanOnly) {
    if (!pkgPathArg) {
      fail('Provide the linked package path to clean its node_modules');
      process.exit(1);
    }
    const resolved = path.resolve(pkgPathArg);
    if (!fs.existsSync(resolved)) { fail(`Path does not exist: ${resolved}`); process.exit(1); }
    if (!fs.existsSync(path.join(resolved, 'package.json'))) { fail(`No package.json in ${resolved}`); process.exit(1); }

    if (!skipPeerCheck) ensurePeerDeps(resolved, PEER_ENFORCE, { dryRun });
    removeConflictsInDir(resolved, packagesToRemove, { dryRun });
    success('Cleanup completed');
    process.exit(0);
  }

  // Full link flow
  const resolved = path.resolve(pkgPathArg);
  if (!fs.existsSync(resolved)) { fail(`Path does not exist: ${resolved}`); process.exit(1); }
  if (!fs.existsSync(path.join(resolved, 'package.json'))) { fail(`No package.json in ${resolved}`); process.exit(1); }

  // 1) enforce peer deps in linked package
  if (!skipPeerCheck) ensurePeerDeps(resolved, PEER_ENFORCE, { dryRun });

  // 2) remove conflicting packages in the LINKED package node_modules
  removeConflictsInDir(resolved, packagesToRemove, { dryRun });

  // 3) link using detected pm
  const pkgName = readPkgName(resolved);
  linkWithPM(pm, resolved, pkgName, { dryRun });

  // 4) Advice: CRA symlinks
  let deps;
  try {
    const pj = readJSON(path.join(projectDir, 'package.json'));
    deps = { ...pj.dependencies, ...pj.devDependencies };
    if (deps && deps['react-scripts']) {
      info('CRA detected. If module resolution errors occur, try:');
      info('  export NODE_OPTIONS=--preserve-symlinks  (bash/zsh)');
      info('  setx NODE_OPTIONS "--preserve-symlinks"  (Windows)');
    }
  } catch {}

  // 5) final clean inside linked package (sometimes link reinstalls)
  removeConflictsInDir(resolved, packagesToRemove, { dryRun });

  success(`Successfully linked ${cyan(pkgName)}!`);

  // Check if the linked package has a dev/watch script
  const linkedPkgJson = readJSON(path.join(resolved, 'package.json'));
  const hasWatchScript = linkedPkgJson.scripts && (linkedPkgJson.scripts.dev || linkedPkgJson.scripts['build:watch']);

  log('\nNext steps:');
  if (hasWatchScript) {
    const watchCmd = linkedPkgJson.scripts.dev ? 'npm run dev' : 'npm run build:watch';
    log(`‚Ä¢ Run ${cyan(watchCmd)} in ${gray(path.basename(resolved))} for live rebuilding`);
    log(`‚Ä¢ Edit files in ${gray(path.basename(resolved))} ‚Üí auto-rebuild ‚Üí changes appear in your app`);
  } else {
    log(`‚Ä¢ Run ${cyan('npm run build')} in ${gray(path.basename(resolved))} after making changes`);
  }

  if (deps && deps['react-scripts']) {
    log(`‚Ä¢ Restart your dev server with: ${cyan('NODE_OPTIONS=--preserve-symlinks npm start')}`);
  } else {
    log('‚Ä¢ Restart your dev server if needed');
  }

  log(`‚Ä¢ To unlink: run ${cyan('npx nice-npm-link --unlink')}`);
}

if (require.main === module) {
  try { main(); }
  catch (e) { fail(e.message || String(e)); process.exit(1); }
}

module.exports = {
  detectPM,
  ensurePeerDeps,
  removeConflictsInDir
};
